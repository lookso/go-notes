/*
@Time : 2019/1/8 10:07 AM
@Author : Tenlu
@File : basic
@Software: GoLand
*/
package main

/*
1.查看进程状态
通过ps aux可以看到进程的状态。

O：进程正在处理器运行,这个状态从来没有见过.
S：休眠状态（sleeping）
R：等待运行（runable）R Running or runnable (on run queue) 进程处于运行或就绪状态
I：空闲状态（idle)
Z：僵尸状态（zombie）
T：跟踪状态（Traced）
B：进程正在等待更多的内存页
D: 不可中断的深度睡眠,一般由IO引起,同步IO在做读或写操作时,cpu不能做其它事情,只能等待,这时进程处于这种状态,如果程序采用异步IO,这种状态应该就很少见到了

其中就绪状态表示进程已经分配到除CPU以外的资源,等CPU调度它时就可以马上执行了。
运行状态就是正在运行了,获得包括CPU在内的所有资源。等待状态表示因等待某个事件而没有被执行,这时候不耗CPU时间,
而这个时间有可能是等待IO、申请不到足够的缓冲区或者在等待信号。

2.进程状态转换

3.进程退出码
任何进程退出时,都会留下退出码,操作系统根据退出码可以知道进程是否正常运行。
退出码是0到255的整数,通常0表示正常退出,其他数字表示不同的错误。

4.死锁
死锁(Deadlock)就是一个进程拿着资源A请求资源B,另一个进程拿着资源B请求资源A，双方都不释放自己的资源，导致两个进程都进行不下去。

5.活锁
举个很简单的例子，两个人相向过独木桥，他们同时向一边谦让，这样两个人都过不去，然后二者同时又移到另一边，这样两个人又过不去了。如果不受其他因素干扰，两个人一直同步在移动，但外界看来两个人都没有前进，这就是活锁。
活锁会导致CPU耗尽的，解决办法是引入随机变量、增加重试次数等。
所以活锁也是程序设计上可能存在的问题，导致进程都没办法运行下去了，还耗CPU。

6.nohup
每个开发者都会躺过这个坑，在命令行跑一个后台程序，关闭终端后发现进程也退出了，网上搜一下发现要用nohup，究竟什么原因呢？
原来普通进程运行时默认会绑定TTY(虚拟终端),关闭终端后系统会给上面所有进程发送TERM信号,这时普通进程也就退出了。当然还有些进程不会退出,
这就是后面将会提到的守护进程。
Nohup的原理也很简单，终端关闭后会给此终端下的每一个进程发送SIGHUP信号，而使用nohup运行的进程则会忽略这个信号，因此终端关闭后进程也不会退出。

7.使用进程锁和使用Flock

这里的进程锁与线程锁、互斥量、读写锁和自旋锁不同，它是通过记录一个PID文件，避免两个进程同时运行的文件锁。
进程锁的作用之一就是可以协调进程的运行，例如crontab使用进程锁解决冲突提到，使用crontab限定每一分钟执行一个任务，
但这个进程运行时间可能超过一分钟，如果不用进程锁解决冲突的话两个进程一起执行就会有问题。
后面提到的项目实例Run也有类似的问题，通过进程锁可以解决进程间同步的问题。
使用PID文件锁还有一个好处,方便进程向自己发停止或者重启信号。

Nginx编译时可指定参数--pid-path=/var/run/nginx.pid,进程起来后就会把当前的PID写入这个文件,当然如果这个文件已经存在了,
也就是前一个进程还没有退出,那么Nginx就不会重新启动。进程管理工具Supervisord也是通过记录进程的PID来停止或者拉起它监控的进程的。

进程锁在特定场景是非常适用的，而操作系统默认不会为每个程序创建进程锁，那我们该如何使用呢？
其实要实现一个进程锁很简单，通过文件就可以实现了。例如程序开始运行时去检查一个PID文件，如果文件存在就直接退出，
如果文件不存在就创建一个，并把当前进程的PID写入文件中。这样我们很容易可以实现读锁，但是所有流程都需要自己控制

8.孤儿进程
孤儿进程与僵尸进程是完全不同的，后面会详细介绍僵尸进程。而孤儿进程借用了现实中孤儿的概念，也就是父进程不在了,
子进程还在运行，这时我们就把子进程的PPID设为1。前面讲PID提到，操作系统会创建进程号为1的init进程,
它没有父进程也不会退出,可以收养系统的孤儿进程

在现实中用户可能刻意使进程成为孤儿进程，这样就可以让它与父进程会话脱钩，成为后面会介绍的守护进程。

9.僵尸进程
当一个进程完成它的工作终止之后,它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。
一个进程使用fork创建子进程,如果子进程退出,而父进程并没有调用wait或waitpid获取子进程的状态信息,那么子进程的进程描述符仍然保存在系统中。
这种进程称之为僵尸进程。

10.守护进程

11.进程间通信

*/

// 死锁
func main() {
	ch := make(chan int)
	<-ch
}

//fatal error: all goroutines are asleep - deadlock!
